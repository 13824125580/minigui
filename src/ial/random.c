/*
 *   This file is part of MiniGUI, a mature cross-platform windowing
 *   and Graphics User Interface (GUI) support system for embedded systems
 *   and smart IoT devices.
 *
 *   Copyright (C) 2002~2019, Beijing FMSoft Technologies Co., Ltd.
 *   Copyright (C) 1998~2002, WEI Yongming
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Or,
 *
 *   As this program is a library, any link to this program must follow
 *   GNU General Public License version 3 (GPLv3). If you cannot accept
 *   GPLv3, you need to be licensed from FMSoft.
 *
 *   If you have got a commercial license of this program, please use it
 *   under the terms and conditions of the commercial license.
 *
 *   For more information about the commercial license, please refer to
 *   <http://www.minigui.com/en/about/licensing-policy/>.
 */
/*
** random.c: the random IAL Engine.
**
** Created by WEI Yongming, 2005/06/08
**
** Enhanced by WEI Yongming to support extra input events in June, 2019.
**
** The MiniGUI runtime configuration key `random.logfile` specifies
** the log file which will store the input events generated by this engine.
** If MiniGUI failed to open the log file, the log feature will be disabled.
**
** The MiniGUI runtime configuration key `random.eventtypes` specifies
** the input event types which will be generated by this IAL engine,
** in the following pattern:
**
**  <event-type>[-<event-type>]*
**
** The <event-type> can be one of the following values:
**
**  - mouse: mouse.
**  - keyboard: keyboard.
**  - joystick: joystick buttons.
**  - button: buttons other than joystick.
**  - single_touch: touch pen or single touch panel.
**  - multi_touch: multiple touch panel.
**  - gesture: gesture.
**  - tablet_tool: tablet tool.
**  - tablet_pad: tablet pad.
**  - switch: switch.
**
** The MiniGUI ETC key `random.maxkeycode` specify the maximal key code
** which can be generated by the engine.
**
** For invalid `random.eventtyps` and `random.maxkeycord key value,
** use `mouse` and `NR_KEYS` respectively.
**
** This engine maintains a state machine for each input event type, and
** generates a reasonable event sequence for each type. If and only if
** an event sequence finished or cancelled, the engine switch to another
** event type randomly.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"

#ifdef _MGIAL_RANDOM

#include "minigui.h"
#include "misc.h"
#include "ial.h"
#include "random.h"

enum _button_state {
    BUTTON_STATE_RELEASED,
    BUTTON_STATE_PRESSED,
};

struct _random_event {
    int type;
};

static struct _event_state_machine {
    const char* name;
} event_state_machines [] = {
    { "mouse", },
    { "keyboard", },
    { "joystick", },
    { "button", },
    { "single_touch", },
    { "multi_touch", },
    { "gesture", },
    { "tablet_tool", },
    { "tablet_pad", },
    { "switch", },
};

struct _random_input_contxt {
    FILE* log_fp;
    int min_x, max_x, min_y, max_y;
    int mouse_x, mouse_y, mouse_button;
    int nr_keys, last_keycode;
    char* kbd_state;
    struct _event_state_machine *esm [TABLESIZE(event_state_machines)];
};

static struct _random_input_contxt my_ctxt;

static void mouse_setrange (int newminx, int newminy, int newmaxx, int newmaxy)
{
    my_ctxt.min_x = newminx;
    my_ctxt.max_x = newmaxx;
    my_ctxt.min_y = newminy;
    my_ctxt.max_y = newmaxy;

    if (my_ctxt.mouse_x < my_ctxt.min_x)
        my_ctxt.mouse_x = my_ctxt.min_x;
    if (my_ctxt.mouse_x > my_ctxt.max_x)
        my_ctxt.mouse_x = my_ctxt.max_x;
    if (my_ctxt.mouse_y < my_ctxt.min_y)
        my_ctxt.mouse_y = my_ctxt.min_y;
    if (my_ctxt.mouse_y > my_ctxt.max_y)
        my_ctxt.mouse_y = my_ctxt.max_y;

    my_ctxt.mouse_x = (my_ctxt.min_x + my_ctxt.max_x) / 2;
    my_ctxt.mouse_y = (my_ctxt.min_y + my_ctxt.max_y) / 2;
}

static void mouse_setxy (int newx, int newy)
{
    if (newx < my_ctxt.min_x)
        newx = my_ctxt.min_x;
    if (newx > my_ctxt.max_x)
        newx = my_ctxt.max_x;
    if (newy < my_ctxt.min_y)
        newy = my_ctxt.min_y;
    if (newy > my_ctxt.max_y)
        newy = my_ctxt.max_y;

    if (newx == my_ctxt.mouse_x && newy == my_ctxt.mouse_y)
        return;

    my_ctxt.mouse_x = newx;
    my_ctxt.mouse_x = newy;
}

static int mouse_update(void)
{
    return 1;
}

static void mouse_getxy (int* x, int* y)
{
    *x = my_ctxt.mouse_x;
    *y = my_ctxt.mouse_y;
}

static int mouse_getbutton(void)
{
    return my_ctxt.mouse_button;
}

static int keyboard_update(void)
{
    if (my_ctxt.last_keycode == 0)
        return 0;

    return my_ctxt.last_keycode + 1;
}

static const char* keyboard_getstate(void)
{
    return my_ctxt.kbd_state;
}

#if 0
static void normalize_mouse_pos(int* new_x, int* new_y)
{
    if (*new_x < my_ctxt.min_x)
        *new_x = my_ctxt.min_x;
    if (*new_x > my_ctxt.max_x)
        *new_x = my_ctxt.max_x;
    if (*new_y < my_ctxt.min_y)
        *new_y = my_ctxt.min_y;
    if (*new_y > my_ctxt.max_y)
        *new_y = my_ctxt.max_y;
}

static BOOL on_mouse_moved (double dx, double dy)
{
    int new_x = (int)(my_ctxt.mouse_x + dx + 0.5);
    int new_y = (int)(my_ctxt.mouse_y + dy + 0.5);

    _DBG_PRINTF("%s: new mouse position: %d, %d (old: %d, %d; delta: %f, %f)\n",
            __FUNCTION__, new_x, new_y, my_ctxt.mouse_x, my_ctxt.mouse_y, dx, dy);

    normalize_mouse_pos(&new_x, &new_y);
    if (new_x == my_ctxt.mouse_x && new_y == my_ctxt.mouse_y)
        return FALSE;

    my_ctxt.mouse_x = new_x;
    my_ctxt.mouse_y = new_y;
    return TRUE;
}

static BOOL on_new_mouse_pos (double x, double y)
{
    int new_x = (int)(x + 0.5);
    int new_y = (int)(y + 0.5);

    _DBG_PRINTF("%s: new mouse position: %d, %d (old: %d, %d)\n",
            __FUNCTION__, new_x, new_y, my_ctxt.mouse_x, my_ctxt.mouse_y);

    normalize_mouse_pos(&new_x, &new_y);
    if (new_x == my_ctxt.mouse_x && new_y == my_ctxt.mouse_y)
        return FALSE;

    my_ctxt.mouse_x = new_x;
    my_ctxt.mouse_y = new_y;
    return TRUE;
}

#ifdef __LINUX__
#include <linux/input-event-codes.h>
#else

/* copied from linux/input-event-codes.h */
#define BTN_LEFT		0x110
#define BTN_RIGHT		0x111
#define BTN_MIDDLE		0x112
#endif

static BOOL on_mouse_button_changed (uint32_t button,
        enum _button_state state)
{
    int old_mouse_button = my_ctxt.mouse_button;

    switch (button) {
    case BTN_LEFT:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_LEFTBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_LEFTBUTTON;
        break;

    case BTN_RIGHT:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_RIGHTBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_RIGHTBUTTON;
        break;

    case BTN_MIDDLE:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_MIDDLEBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_MIDDLEBUTTON;
        break;

    default:
        // not a standard mouse button.
        return FALSE;
    }

    _DBG_PRINTF("%s: new mouse button: 0x%x (old: 0x%x)\n",
            __FUNCTION__, my_ctxt.mouse_button, old_mouse_button);
    if (old_mouse_button == my_ctxt.mouse_button)
        return FALSE;

    return TRUE;
}
#endif

static struct _random_event* get_random_event(struct _random_input_contxt* ctxt)
{
    return NULL;
}

static int wait_event_ex (int maxfd, fd_set *in, fd_set *out, fd_set *except,
                struct timeval *timeout, EXTRA_INPUT_EVENT* extra)
{
    struct _random_event *event;
    int retval;

    event = get_random_event(&my_ctxt);
    if (event == NULL) {
        retval = select (maxfd + 1, in, out, except, timeout);
        if (retval >= 0) {
            return 0;
        }
        else {
            return -1;
        }
    }

    return 0;
}

#define LEN_EVENT_TYPES     127

BOOL InitRandomInput (INPUT* input, const char* mdev, const char* mtype)
{
    char logfile[MAX_PATH + 1];
    char eventtypes[LEN_EVENT_TYPES + 1];
    int i, n;

    if (GetMgEtcValue ("random", "logfile", logfile, MAX_PATH) == ETC_OK) {
        my_ctxt.log_fp = fopen(logfile, "a");
        if (my_ctxt.log_fp == NULL) {
            _WRN_PRINTF("Failed to open file %s for logging; log disabled",
                logfile);
        }
    }
    else {
        _WRN_PRINTF("No log file defined; log disabled");
    }

    if (GetMgEtcIntValue ("random", "maxkeycode", &my_ctxt.nr_keys) < 0 ||
            my_ctxt.nr_keys <= 0) {
        _WRN_PRINTF("Bad ETC key value: random.maxkeycode; use default: %d",
                NR_KEYS);
        my_ctxt.nr_keys = NR_KEYS;
    }

    my_ctxt.kbd_state = calloc(my_ctxt.nr_keys, sizeof(char));
    if (my_ctxt.kbd_state == NULL) {
        _ERR_PRINTF("IAL>RANDOM: failed to allocate space for key state\n");
        return FALSE;
    }

    if (GetMgEtcValue ("random", "eventtypes", eventtypes, LEN_EVENT_TYPES) < 0) {
        _WRN_PRINTF("Bad ETC key value: random.eventtypes; use default: %s",
                "mouse");
        strcpy(eventtypes, "mouse");
    }

    n = 0;
    for (i = 0; i < TABLESIZE(event_state_machines); i++) {
        if (strstr(eventtypes, event_state_machines[i].name)) {
            my_ctxt.esm[n] = event_state_machines + i;
            n++;
        }
    }

    input->update_mouse = mouse_update;
    input->get_mouse_xy = mouse_getxy;
    input->set_mouse_xy = mouse_setxy;
    input->get_mouse_button = mouse_getbutton;
    input->set_mouse_range = mouse_setrange;
    input->suspend_mouse= NULL;
    input->resume_mouse = NULL;

    input->update_keyboard = keyboard_update;
    input->get_keyboard_state = keyboard_getstate;
    input->suspend_keyboard = NULL;
    input->resume_keyboard = NULL;
    input->set_leds = NULL;
    input->wait_event_ex = wait_event_ex;

    srand (__mg_os_get_random_seed ());
    return TRUE;
}

void TermRandomInput (void)
{
    if (my_ctxt.log_fp)
        fclose(my_ctxt.log_fp);
    if (my_ctxt.kbd_state)
        free(my_ctxt.kbd_state);
}

#endif /* _MGIAL_RANDOM */


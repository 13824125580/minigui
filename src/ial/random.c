/*
 *   This file is part of MiniGUI, a mature cross-platform windowing
 *   and Graphics User Interface (GUI) support system for embedded systems
 *   and smart IoT devices.
 *
 *   Copyright (C) 2002~2019, Beijing FMSoft Technologies Co., Ltd.
 *   Copyright (C) 1998~2002, WEI Yongming
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Or,
 *
 *   As this program is a library, any link to this program must follow
 *   GNU General Public License version 3 (GPLv3). If you cannot accept
 *   GPLv3, you need to be licensed from FMSoft.
 *
 *   If you have got a commercial license of this program, please use it
 *   under the terms and conditions of the commercial license.
 *
 *   For more information about the commercial license, please refer to
 *   <http://www.minigui.com/en/about/licensing-policy/>.
 */
/*
** random.c: the random IAL Engine.
**
** Created by WEI Yongming, 2005/06/08
**
** Enhanced by WEI Yongming to support extra input events in June, 2019.
**
** The MiniGUI runtime configuration key `random.logfile` specifies
** the log file which will store the input events generated by this engine.
** If MiniGUI failed to open the log file, the log feature will be disabled.
**
** The MiniGUI runtime configuration key `random.eventtypes` specifies
** the input event types which will be generated by this IAL engine,
** in the following pattern:
**
**  <event-type>[-<event-type>]*
**
** The <event-type> can be one of the following values:
**
**  - mouse: mouse.
**  - keyboard: keyboard.
**  - joystick: joystick buttons.
**  - button: buttons other than joystick.
**  - single_touch: touch pen or single touch panel.
**  - multi_touch: multiple touch panel.
**  - gesture: gesture.
**  - tablet_tool: tablet tool.
**  - tablet_pad: tablet pad.
**  - switch: switch.
**
** The MiniGUI ETC key `random.maxkeycode` specifies the maximal key code
** which can be generated by the engine.
**
** For invalid `random.eventtyps` and `random.maxkeycord key value,
** use `mouse` and `NR_KEYS` respectively.
**
** This engine maintains a state machine for each input event type, and
** generates a reasonable event sequence for each type. If and only if
** an event sequence finished or cancelled, the engine switch to another
** event type randomly.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define _DEBUG
#include "common.h"

#ifdef _MGIAL_RANDOM

#include <time.h>
#include <sys/time.h>

#include "minigui.h"
#include "misc.h"
#include "ial.h"
#include "random.h"

#define BTN_NONE        0

#ifdef __LINUX__
#include <linux/input-event-codes.h>
#else

/* copied from linux/input-event-codes.h */
#define BTN_LEFT        0x110
#define BTN_RIGHT       0x111
#define BTN_MIDDLE      0x112
#endif

enum _random_event_type {
    RANDOM_EVENT_NONE,
    RANDOM_EVENT_WAIT,
    RANDOM_EVENT_MOUSE_MOTION,
    RANDOM_EVENT_MOUSE_BUTTON,
    RANDOM_EVENT_KEYBOARD_KEY,
};

struct _random_event {
    enum _random_event_type type;
};

typedef void* (*op_start_event_machine)(void);
typedef void (*op_stop_event_machine)(void* machine);
typedef const struct _random_event* (*op_generate_event)(void* machine);

enum _button_state {
    BUTTON_STATE_RELEASED,
    BUTTON_STATE_PRESSED,
};

enum _key_state {
    KEY_STATE_RELEASED,
    KEY_STATE_PRESSED,
};

/* state machine for mouse */
struct _mouse_event {
    struct _random_event event;
    uint32_t            button;
    enum _button_state  state;
    int                 dx, dy;
};

enum _mouse_op_type {
    MOUSE_OP_IDLE = 0,
    MOUSE_OP_MOVE,
    MOUSE_OP_CLICK,
    MOUSE_OP_PRESSED_MOVE,
    MOUSE_OP_COUNT,
};

struct _mouse_event_machine {
    struct _mouse_event event;
    enum _mouse_op_type op_type;
    int                 op_sec;
    time_t              op_start;

    uint32_t            btn_sel;
    uint32_t            btn_down;
};

static void* start_event_machine_mouse(void)
{
    struct _mouse_event_machine* machine;
    machine = calloc(1, sizeof (struct _mouse_event_machine));

    machine->op_type = MOUSE_OP_IDLE;
    machine->op_sec = random() % 5;
    machine->op_start = time(NULL);
    return machine;
}

static void stop_event_machine_mouse(void* machine)
{
    if (machine)
        free(machine);
}

static const struct _random_event* generate_event_mouse(void* machine)
{
    struct _mouse_event_machine* my_machine =
            (struct _mouse_event_machine*)machine;
    time_t now = time(NULL);

    memset(&my_machine->event, 0, sizeof(my_machine->event));

    if ((now - my_machine->op_start) > my_machine->op_sec &&
            my_machine->btn_down == BTN_NONE) {
        my_machine->op_type = now % MOUSE_OP_COUNT;
        my_machine->op_sec = random() % 5;
        my_machine->op_start = time(NULL);

        switch (now % 5) {
        case 0:
            my_machine->btn_sel = BTN_RIGHT;
            break;
        case 1:
            my_machine->btn_sel = BTN_MIDDLE;
            break;
        default: /* 60% possibility to choose the left button. */
            my_machine->btn_sel = BTN_LEFT;
            break;
        }

        __mg_os_time_delay(100);
        my_machine->event.event.type = RANDOM_EVENT_NONE;
        goto ret;
    }

    /* valid operation */
    if ((GetTickCount() % 5)) {
        // 80% possibility to wait for a new event.
        __mg_os_time_delay(10);
        my_machine->event.event.type = RANDOM_EVENT_WAIT;
        goto ret;
    }

    switch (my_machine->op_type) {
    case MOUSE_OP_IDLE:
        my_machine->event.event.type = RANDOM_EVENT_WAIT;
        break;

    case MOUSE_OP_MOVE:
        my_machine->event.event.type = RANDOM_EVENT_MOUSE_MOTION;
        my_machine->event.dx = random() % 100 - 50;
        my_machine->event.dy = random() % 100 - 50;
        break;

    case MOUSE_OP_CLICK:
        if (my_machine->btn_down == BTN_NONE) {
            my_machine->btn_down = my_machine->btn_sel;

            my_machine->event.event.type = RANDOM_EVENT_MOUSE_BUTTON;
            my_machine->event.button = my_machine->btn_down;
            my_machine->event.state = BUTTON_STATE_PRESSED;
        }
        else {
            my_machine->event.event.type = RANDOM_EVENT_MOUSE_BUTTON;
            my_machine->event.button = my_machine->btn_down;
            my_machine->event.state = BUTTON_STATE_RELEASED;

            my_machine->btn_down = BTN_NONE;
        }
        break;

    case MOUSE_OP_PRESSED_MOVE:
        if (my_machine->btn_down == BTN_NONE) {
            my_machine->btn_down = my_machine->btn_sel;

            my_machine->event.event.type = RANDOM_EVENT_MOUSE_BUTTON;
            my_machine->event.button = my_machine->btn_down;
            my_machine->event.state = BUTTON_STATE_PRESSED;
        }
        else if ((GetTickCount() % 5) == 0) {
            my_machine->event.event.type = RANDOM_EVENT_MOUSE_BUTTON;
            my_machine->event.button = my_machine->btn_down;
            my_machine->event.state = BUTTON_STATE_RELEASED;

            my_machine->btn_down = BTN_NONE;
        }
        else {
            my_machine->event.event.type = RANDOM_EVENT_MOUSE_MOTION;
            my_machine->event.dx = random() % 100 - 50;
            my_machine->event.dy = random() % 100 - 50;
        }
        break;

    default:
        assert(0);
        break;
    }

ret:
    return &my_machine->event.event;
}

static inline struct _mouse_event* get_mouse_event(struct _random_event* event)
{
    if (event->type != RANDOM_EVENT_MOUSE_MOTION &&
            event->type != RANDOM_EVENT_MOUSE_BUTTON)
        return NULL;

    return (struct _mouse_event*)event;
}

static struct _event_state_machine {
    const char* name;
    op_start_event_machine start_machine;
    op_stop_event_machine stop_machine;
    op_generate_event generate_event;
    void*       machine;
} event_state_machines [] = {
    { "mouse",
        start_event_machine_mouse,
        stop_event_machine_mouse,
        generate_event_mouse},
    { "keyboard", },
    { "joystick", },
    { "button", },
    { "single_touch", },
    { "multi_touch", },
    { "gesture", },
    { "tablet_tool", },
    { "tablet_pad", },
    { "switch", },
};

struct _random_input_contxt {
    FILE* log_fp;
    int min_x, max_x, min_y, max_y;
    int mouse_x, mouse_y, mouse_button;
    int nr_keys, last_keycode;
    char* kbd_state;

    struct _event_state_machine *esm [TABLESIZE(event_state_machines)];
    int nr_machines;
};

static struct _random_input_contxt my_ctxt;

static void mouse_setrange (int newminx, int newminy, int newmaxx, int newmaxy)
{
    my_ctxt.min_x = newminx;
    my_ctxt.max_x = newmaxx;
    my_ctxt.min_y = newminy;
    my_ctxt.max_y = newmaxy;

    my_ctxt.mouse_x = (my_ctxt.min_x + my_ctxt.max_x) / 2;
    my_ctxt.mouse_y = (my_ctxt.min_y + my_ctxt.max_y) / 2;
}

static void mouse_setxy (int newx, int newy)
{
    if (newx < my_ctxt.min_x)
        newx = my_ctxt.min_x;
    if (newx > my_ctxt.max_x)
        newx = my_ctxt.max_x;
    if (newy < my_ctxt.min_y)
        newy = my_ctxt.min_y;
    if (newy > my_ctxt.max_y)
        newy = my_ctxt.max_y;

    if (newx == my_ctxt.mouse_x && newy == my_ctxt.mouse_y)
        return;

    my_ctxt.mouse_x = newx;
    my_ctxt.mouse_x = newy;
}

static int mouse_update(void)
{
    return 1;
}

static void mouse_getxy (int* x, int* y)
{
    *x = my_ctxt.mouse_x;
    *y = my_ctxt.mouse_y;
}

static int mouse_getbutton(void)
{
    return my_ctxt.mouse_button;
}

static int keyboard_update(void)
{
    if (my_ctxt.last_keycode == 0)
        return 0;

    return my_ctxt.last_keycode + 1;
}

static const char* keyboard_getstate(void)
{
    return my_ctxt.kbd_state;
}

#if 0
static void normalize_mouse_pos(int* new_x, int* new_y)
{
    if (*new_x < my_ctxt.min_x)
        *new_x = my_ctxt.min_x;
    if (*new_x > my_ctxt.max_x)
        *new_x = my_ctxt.max_x;
    if (*new_y < my_ctxt.min_y)
        *new_y = my_ctxt.min_y;
    if (*new_y > my_ctxt.max_y)
        *new_y = my_ctxt.max_y;
}

static BOOL on_mouse_moved (double dx, double dy)
{
    int new_x = (int)(my_ctxt.mouse_x + dx + 0.5);
    int new_y = (int)(my_ctxt.mouse_y + dy + 0.5);

    _DBG_PRINTF("%s: new mouse position: %d, %d (old: %d, %d; delta: %f, %f)\n",
            __FUNCTION__, new_x, new_y, my_ctxt.mouse_x, my_ctxt.mouse_y, dx, dy);

    normalize_mouse_pos(&new_x, &new_y);
    if (new_x == my_ctxt.mouse_x && new_y == my_ctxt.mouse_y)
        return FALSE;

    my_ctxt.mouse_x = new_x;
    my_ctxt.mouse_y = new_y;
    return TRUE;
}

static BOOL on_new_mouse_pos (double x, double y)
{
    int new_x = (int)(x + 0.5);
    int new_y = (int)(y + 0.5);

    _DBG_PRINTF("%s: new mouse position: %d, %d (old: %d, %d)\n",
            __FUNCTION__, new_x, new_y, my_ctxt.mouse_x, my_ctxt.mouse_y);

    normalize_mouse_pos(&new_x, &new_y);
    if (new_x == my_ctxt.mouse_x && new_y == my_ctxt.mouse_y)
        return FALSE;

    my_ctxt.mouse_x = new_x;
    my_ctxt.mouse_y = new_y;
    return TRUE;
}

static BOOL on_mouse_button_changed (uint32_t button,
        enum _button_state state)
{
    int old_mouse_button = my_ctxt.mouse_button;

    switch (button) {
    case BTN_LEFT:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_LEFTBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_LEFTBUTTON;
        break;

    case BTN_RIGHT:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_RIGHTBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_RIGHTBUTTON;
        break;

    case BTN_MIDDLE:
        if (state == BUTTON_STATE_RELEASED)
            my_ctxt.mouse_button &= ~IAL_MOUSE_MIDDLEBUTTON;
        else
            my_ctxt.mouse_button |= IAL_MOUSE_MIDDLEBUTTON;
        break;

    default:
        // not a standard mouse button.
        return FALSE;
    }

    _DBG_PRINTF("%s: new mouse button: 0x%x (old: 0x%x)\n",
            __FUNCTION__, my_ctxt.mouse_button, old_mouse_button);
    if (old_mouse_button == my_ctxt.mouse_button)
        return FALSE;

    return TRUE;
}
#endif

static struct _random_event* get_random_event(struct _random_input_contxt* ctxt)
{
    
    return NULL;
}

static int wait_event_ex (int maxfd, fd_set *in, fd_set *out, fd_set *except,
                struct timeval *timeout, EXTRA_INPUT_EVENT* extra)
{
    struct _random_event *event;
    int retval;

    event = get_random_event(&my_ctxt);
    if (event == NULL) {
        retval = select (maxfd + 1, in, out, except, timeout);
        if (retval >= 0) {
            return 0;
        }
        else {
            return -1;
        }
    }

    return 0;
}

#define LEN_EVENT_TYPES     127

BOOL InitRandomInput (INPUT* input, const char* mdev, const char* mtype)
{
    char logfile[MAX_PATH + 1];
    char eventtypes[LEN_EVENT_TYPES + 1];
    int i;

    if (GetMgEtcValue ("random", "logfile", logfile, MAX_PATH) == ETC_OK) {
        my_ctxt.log_fp = fopen(logfile, "a");
        if (my_ctxt.log_fp == NULL) {
            _WRN_PRINTF("Failed to open file %s for logging; log disabled",
                logfile);
        }
    }
    else {
        _WRN_PRINTF("No log file defined; log disabled");
    }

    if (GetMgEtcIntValue ("random", "maxkeycode", &my_ctxt.nr_keys) < 0 ||
            my_ctxt.nr_keys <= 0) {
        _WRN_PRINTF("Bad ETC key value: random.maxkeycode; use default: %d",
                NR_KEYS);
        my_ctxt.nr_keys = NR_KEYS;
    }

    my_ctxt.kbd_state = calloc(my_ctxt.nr_keys, sizeof(char));
    if (my_ctxt.kbd_state == NULL) {
        _ERR_PRINTF("IAL>RANDOM: failed to allocate space for key state\n");
        return FALSE;
    }

    if (GetMgEtcValue ("random", "eventtypes", eventtypes, LEN_EVENT_TYPES) < 0) {
        _WRN_PRINTF("Bad ETC key value: random.eventtypes; use default: %s",
                "mouse");
        strcpy(eventtypes, "mouse");
    }

    my_ctxt.nr_machines = 0;
    for (i = 0; i < TABLESIZE(event_state_machines); i++) {
        if (strstr(eventtypes, event_state_machines[i].name)) {
            struct _event_state_machine* machine = event_state_machines + i;

            if (machine->start_machine &&
                    (machine->machine = machine->start_machine())) {
                my_ctxt.esm[my_ctxt.nr_machines] = machine;
                _DBG_PRINTF("IAL>RANDOM: start event machine for %s: %p\n",
                        event_state_machines[i].name,
                        my_ctxt.esm[my_ctxt.nr_machines]->machine);
                my_ctxt.nr_machines++;
            }
        }
    }

    assert(my_ctxt.nr_machines > 0);

    input->update_mouse = mouse_update;
    input->get_mouse_xy = mouse_getxy;
    input->set_mouse_xy = mouse_setxy;
    input->get_mouse_button = mouse_getbutton;
    input->set_mouse_range = mouse_setrange;
    input->suspend_mouse= NULL;
    input->resume_mouse = NULL;

    input->update_keyboard = keyboard_update;
    input->get_keyboard_state = keyboard_getstate;
    input->suspend_keyboard = NULL;
    input->resume_keyboard = NULL;
    input->set_leds = NULL;
    input->wait_event_ex = wait_event_ex;

    srand (__mg_os_get_random_seed ());
    return TRUE;
}

void TermRandomInput (void)
{
    int i;

    for (i = 0; i < TABLESIZE(event_state_machines); i++) {
        if (my_ctxt.esm[i]->machine) {
            if (my_ctxt.esm[i]->stop_machine)
                my_ctxt.esm[i]->stop_machine(my_ctxt.esm[i]->machine);
            else
                free (my_ctxt.esm[i]->machine);

            my_ctxt.esm[i]->machine = NULL;
        }
    }

    if (my_ctxt.log_fp) {
        fclose(my_ctxt.log_fp);
        my_ctxt.log_fp = NULL;
    }

    if (my_ctxt.kbd_state) {
        free(my_ctxt.kbd_state);
        my_ctxt.kbd_state = NULL;
    }
}

#endif /* _MGIAL_RANDOM */

